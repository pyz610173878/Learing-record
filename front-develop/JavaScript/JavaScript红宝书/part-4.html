<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      const log = console.log.bind(console);
      const dir = console.dir.bind(console);

      // 4.1 原始类型值与引用值

      // var name = 12;
      // name.age = 44;
      // log(name.age)

      // 4.1.1 原始值与引用值 存储区别.处理区别.
      let name = 5;
      let name1 = name;

      // 1. 2 复制区别
      //   在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。
      // 操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来

      let person2 = new Object();
      person2.name = "jack";
      let obj = person2;

      log(obj.name);

      // 相互独立 name1变量的修改,不会影响name.

      // 当变量是原始值时,进行传递

      // 1.3 函数参数的传递,其实也是一种值的传递.

      const part1 = function () {
        function addTen(num) {
          num += 10;
          return num;
        }
        let count = 20;
        let result = addTen(count);
        console.log(count); // 20 - no change
        console.log(result); // 30
      };

      // 那如果参数的传递不是原始值呢?
      // 是否会不一样.
      function setName(obj) {
        obj.name = "Nicholas";
      }

      let person = new Object();
      setName(person);
      console.log(person.name); // "Nicholas"
      //   如果是原始值,则不会改变.

      function setName1(obj) {
        obj.name = "Nicholas";
        obj = new Object();
        obj.name = "Greg";
      }

      //
      let person1 = new Object();
      setName(person);
      console.log(person1.name); // "Nicholas"

      //对我目前的水平来说还是太晦涩了.
      // 一天看两小节吧.

      function f1(n) {
        if (n == 1) return 1;
        return n * f1(n / 2);
      }


      2 * f1(2 / 2)   // 2
      3 * f1(3 / 2)
      4 * f1(4 / 2)
      5 * f1(5 / 2)
    </script>
  </body>
</html>
