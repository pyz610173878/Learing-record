# 6.  面向对象编程

## 6.1  实例对象与 new 命令

## 2.  构造函数

典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。

JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。

即构造函数这个概念对应着其他编程语言中**类**这个概念。

对象与实例对象

### 2.1 构造函数的特点

```javascript
var Vehicle = function () {
  this.price = 1000;
};

1. 函数内部使用this关键字
2. 生成实例对象时必须使用new命令
```

竟然在js中万物皆对象，那么这些对象都是用构造函数创造出来的。

### 2.1  创建与实例化

```javascript
        var Animal = function (name, jiaosheng, age) {
            this.name = name;
            this.jiaosheng = jiaosheng;
            this.age = age;
        };

        
        var dog = new animal("柴犬", "wawawa", 5);
        log(dog.name)
        log(dog.jiaosheng)
        log(dog.age)
```

## 3.  new 命令

### 3.1  基本用法

通过`new`命令创建实例化对象.

```javascript

构造函数可以不添加参数，也可以添加参数        
var animal = function (name, jiaosheng, age) {
            this.name = name;
            this.jiaosheng = jiaosheng;
            this.age = age;
        };

        var dog = new animal("柴犬", "wawawa", 5);
```

### 3.2 new 命令的原理

示例

```javascript
 var Animal = function (name, jiaosheng, age) {
        this.name = name;
        this.jiaosheng = jiaosheng;
        this.age = age;
      };

      new animal("柴犬", "wawawa", 5);
	//这样不会报错。只是实例对象没有用名字。
```



1.  创建一个空对象，作为将要返回的对象实例。
2.  将这个空对象的`原型`，指向构造函数的`prototype`属性。

根据上面的例子，将实例对象的原型，指向Animal 的prototype属性。我只要在

3.  将这个空对象赋值给函数内部的`this`关键字。
2.  开始执行构造函数内部的代码。



### 3.3 构造函数中使用 return 语句的注意点

`return`后面跟着一个对象，`new`命令会返回`return`语句指定的对象；

否则，就会不管`return`语句，返回`this`对象. 实例出现的对象。

```javascript
var Vehicle = function () {
  this.price = 1000;
  return 1000;
};

(new Vehicle()) === 1000
// false
// 因为是数值，return会忽略数值，返回this对象，也就是实例对象。
```

### 3.4 new.target

函数内部可以使用`new.target`属性。如果当前函数是`new`命令调用，`new.target`指向当前函数，否则为`undefined`

作用: 用来判断是否使用了 new命令



## 4.  Object.create() 创建实例对象



## 6.2  this 关键字

`this`关键字返回值的共性之一:是一个对象。

简单的说:指向一个对象的属性或者方法。

```javascript
实例:
var animal = function (name, jiaosheng, age) {
            this.name = name;
            this.jiaosheng = jiaosheng;
            this.age = age;
        };

        var dog = new animal("柴犬", "wawawa", 5);
		log(dog.name)
		log(dog.age)
		log(dog.jiaosheng)

实例2:
var person = {
  name: '张三',
  describe: function () {
    return '姓名：'+ this.name;
  }
};

person.describe()
// "姓名：张三"



3： 只要函数被赋给另一个变量，this的指向就会变。
        var A = {
            name: '张三',
            describe: function () {
                return '姓名：' + this.name;
            }
        };
        // 对象a的name属性值 为张三
        var name = '李四';
        // 定义一个全局变量name.
        var f = A.describe; //这个相当于为函数去一个化名嘛！
        f() // "姓名：李四" 
        //此时 函数f中this的指向变成了全局变量name的值 李四
```



### 4.    使用注意点

### 4.1  避免多层 this

前提:  由于`this`的指向是不确定的，

结论:  所以切勿在函数中包含多层的`this`

```javascript
实例:
var o = {
  f1: function () {
    console.log(this);
    var f2 = function () {
      console.log(this);
    }();
  }
}

o.f1()
// Object
// Window
//根据进一步的猜想验证:
1.  即使不为匿名函数赋值，this指向也是全局变量window
2.  f2函数体外的括号让f1函数再次调用。暂时无法理解记录下来。
```



一个解决方法是在第二层改用一个指向外层`this`的变量。

```javascript

var o = {
  f1: function() {
    console.log(this);
    var that = this;
    var f2 = function() {
      console.log(that);
    }();
  }
}


o.f1()
// Object
// Object
        // 猜想与验证
        //什么时候使用变量固定this的值？
        //为什么使用变量固定this的值？

        // 实例1:
        var o = {
            f1: function() {
                log(this);
                var that1 = this;
                var f2 = function() {
                    var that = this;
                    log(that1);
                }();
            }
        }


        o.f1()
        // Object
        // Window
        // Object

        // 根据验证，变量放在f2函数体内，this的指向依旧发生了变化。
        // 即f2函数的执行改变了this的指向。
        // 最佳的做法变量放在this值的下一行。(我应该如何表述？)
```



### 4.3  避免回调函数中的 this

回调函数中的`this`往往会改变指向，最好避免使用。

```javascript
<button style="width: 40px;"></button>   

window.onload = function () {
            var o = new Object();
            o.f = function () {
                console.log(this === o);
            }
            var btns = document.querySelector("button")
            btns.addEventListener("click", o.f = function () {
                console.log(this === o);
            })
        }
     //false
```

当触发绑定事件，this的指向变为DOM对象，因为`f`方法是在按钮对象的环境中被调用的。



### 5.  绑定 this 的方法

未看

