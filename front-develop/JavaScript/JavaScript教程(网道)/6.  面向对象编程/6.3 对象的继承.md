# 6.2 对象的继承

## 1. 原型对象概述

### 1.1 构造函数的缺点

答: 同一个构造函数的多个实例之间，无法共享属性与方法，从而造成对系统资源的浪费。

同一个构造函数的不同实例对象无法共享属性与方法。

```javascript
var Person = function (name, age) {
            this.name = name
            this.age = age
            this.think = function () {
                log("丰富 全面 深入")
            }
        }


        var person1 = new Person('pyz', '22');
        var person2 = new Person('lxl', '50');
        log(person1.name === person2.name)
        log(person1.think === person2.think)

        // false
        // false
```



### 1.2 prototype 属性的作用

原型对象的所有属性和方法，都能被实例对象共享。即如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。

疑问:

原型对象是否对应着Python中基类这个概念？

js规定，在函数生成的时候，会自动添加一个prototype属性。这个属性默认指向一个对象。但是这个属性对普通函数没有什么作用。

当构造函数生成实例的时候，**该属性会自动成为`实例对象`的原型**。





通过验证得来的。

实例对象能够使用构造函数prototype属性中定义的属性与方法。

实例化的对象没有prototype属性。

```JavaScript
var Person = function (name, age) {
            this.name = name
            this.age = age
            this.think = function () {
                log("丰富 全面 深入")
            }
        }

		Person.prototype.color = 'white';
        var person1 = new Person('pyz', '22');
        var person2 = new Person('lxl', '50');

		
		 person1.color
          person2.color
		//white
		//white
```

原型对象中的属性不是实例对象的属性,如果修改属性值,变动就立刻会体现在**所有**实例对象上.

```javascript
	 Person.prototype.color = 'black';
	 person1.color
     person2.color
	 //black
	 //black
```





### 1.3 原型链

JavaScript规定，**所有对象都有自己的原型对象**（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型。



如果一层层地上溯，所有对象的原型最终都可以上溯到`Object.prototype`，即`Object`构造函数的`prototype`属性。也就是说，所有对象都继承了`Object.prototype`的属性。这就是所有对象都有`valueOf`和`toString`方法的原因，因为这是从`Object.prototype`继承的

1. 所有生成出来的对象都继承了Object对象的属性与方法，即Object是所有对象的基类。



```javascript
var MyArray = function () {};

MyArray.prototype = new Array();
MyArray.prototype.constructor = MyArray;

var mine = new MyArray();
mine.push(1, 2, 3);
mine.length // 3
mine instanceof Array // true
```







### 1.4 constructor 属性

`prototype`对象有一个`constructor`属性，默认指向`prototype`对象所在的**构造函数**.



```javascript
var Person = function() {
                log("as")
            }
            var p = new Person();
            log(p.constructor)
	
	//返回Person构造函数
```

由于`constructor`属性定义在`prototype`对象上面，意味着可以被所有实例对象继承。

实例对象本身没有constructor。



## 2. `instanceof` 运算符

返回值布尔值，判断对象是否为某个构造函数的实例。

```
v instanceof Vehicle // true
```

1.  左边为实例对象 右边为原型对象
2.  instanceof检查整个原型链

也就是说，一个实例对象存在多个原型对象

## 3. 构造函数的继承

第一步是在子类的构造函数中，调用父类的构造函数

```javascript
function Shape() {
  this.x = 0;
  this.y = 0;
}

Shape.prototype.move = function (x, y) {
  this.x += x;
  this.y += y;
  console.info('Shape moved.');
};

我们需要让Rectangle构造函数继承Shape。

// 第一步，子类继承父类的实例
function Rectangle() {
  Shape.call(this); // 调用父类构造函数
}
// 另一种写法
function Rectangle() {
  this.base = Shape;
  this.base();
}

// 第二步，子类继承父类的原型
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;

采用这样的写法以后，instanceof运算符会对子类和父类的构造函数，都返回true。

var rect = new Rectangle();

rect instanceof Rectangle  // true
rect instanceof Shape  // true


给子类创建属于自己的方法。(即自己的独有的行为与属性)

子类原型对象.prototype.(属性或者方法) = function() {
  console.log("I'm flying!");
};

```





## 4. 多重继承

即一个对象继承多个构造函数()，同时存在多个基类。





## 5. 模块

但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。

如何利用对象实现模块的效果。

### 5.1 基本的实现方法

缺点: 暴露所有模块成员，即外部可以轻易修改成员的属性与方法。

```javascript

var module1 = new Object( {
            _count: 0,
            m1: function () {
                return 23;
            },
            m2: function () {
                //...
            }
        } );


	module1._count  // 0
     module1.m1()  // 23
     
var module1 = {
            _count: 0,
            m1: function () {
                return 23;
            },
            m2: function () {
                //...
            }
        } 


	module1._count  // 0
     module1.m1()  // 23

请说明两者之间的区别？
没有区别。

		// 疑问:
        // 1. 为什么参数可以写成对象的形式？
		  Object是对象，他可以接受这种参数形式，

	   //  2. 为什么这种写法会暴露模块中的属性与方法，即能够在外部进行重写。		
	   //  因为他是一个对象，对象中的属性与方法，可以在全局变量中修改。

        // 猜想与印证
        // 1. 除了可以写成对象的形式，那参数还能写成什么形式呢？
        // 2. 
        

        // 为了理解这段代码我还需要回顾哪些知识？
        // 1. 对象的基本知识 
        // 2. Object对象
        // 3. new命令的基本原理
```



### 5.2 封装私有变量: 构造函数

利用构造函数，封装私有变量

```javascript
function StringBuilder() {
  var buffer = [];

  this.add = function (str) {
     buffer.push(str);
  };

  this.toString = function () {
    return buffer.join('');
  };

}
//现在buffer是构造函数StringBuilder的局域变量，外部无法之间访问。
//只有实例对象可以访问局域变量域。
```

