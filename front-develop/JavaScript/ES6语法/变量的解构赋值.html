<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        const log = console.log.bind(console)
        const dir = console.dir.bind(console)



        // 1. 数组的解构赋值

        //ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构


        let a = 1;
        let b = 2;


        let [s, o, s] = [4, 0, 4];


        // 嵌套数组对变量进行赋值。

        let [foo, [[bar], baz]] = [1, [[2], 3]];
        foo // 1
        bar // 2
        baz // 3

        // 输出结果与上面相同，那么这样做的好处在哪呢？

        let [, , third] = ["foo", "bar", "baz"];
        third // "baz"


        let [x, , y] = [1, 2, 3];
        x // 1
        y // 3

        // 省略参数
        // 疑问记录:
        // 为什么要这样，这样有什么好处？
        // 具体的值传给谁了呢？
        let [head, ...tail] = [1, 2, 3, 4];
        head // 1
        tail // [2, 3, 4]

        // 参数可以接受多个值，即数组。


        let [x, y, ...z] = ['a'];
        x // "a"
        y // undefined
        z // []




        // 共性
        // 1. 不管是变量名还是值，都需要已[]表示。



        // 如果解构不成功，返回undefind

        let [foo] = [];
        let [bar, foo] = [1];



        // 另一种情况是不完全解构，即等号左边的模式，
        // 只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。

        let [x, y] = [1, 2, 3];
        x // 1
        y // 2

        let [a, [b], d] = [1, [2, 3], 4];
        a // 1
        b // 2
        d // 4



        // 如果等号的右边不是数组，就会报错。
        // 报错
        let [foo] = 1;
        let [foo] = false;
        let [foo] = NaN;
        let [foo] = undefined;
        let [foo] = null;
        let [foo] = {};

        // 为什么会报错的理由:
        // 因为等号右边的值，要么转为对象以后不具备 Iterator 接口
        // 要么本身不具备 Iterator 接口（最后一个表达式）。

        // 记录:
        // Iterator接口.
        // 什么是接口
        // 这里的接口指的是 interface

        // 
        // 程序设计 接口  软件接口  模块化设计 编程范型
        //   软件工程  软件开发


        // 对于 Set 结构，也可以使用数组的解构赋值。

        let [x, y, z] = new Set(['a', 'b', 'c']);
        x // "a"

        // 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。

        function* fibs() {
            let a = 0;
            let b = 1;
            while (true) {
                yield a;
                [a, b] = [b, a + b];
            }
        }

        let [first, second, third, fourth, fifth, sixth] = fibs();
        sixth // 5

        // 上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。




        // 1. 2 默认值
        // 前提: 解构赋值允许指定默认值

        let [Truth = "无法改变"] = [];
        // Truth = "无法改变"


        let [x = 1, b] = [2];
        b

        // 重复劳动的都是浪费时间的。
        // 比如:每次看输出结果都需要，打开浏览器的控制台。
        // 假设一下，在工作中，我们要测试整个软件是否正常运行，那不可能用控制台这种方式吧。
        // 这个工作肯定可以实现自动化测试，而且肯定有良好的解决方案。

        // 如何搜索呢？


        // 记录 ===和== 之间的区别
        // 什么是惰性函数。




        // 返回一个数组

        function example() {
            return [2, 3, 5];
        }
        let [a, b, c] = example();

        // 返回一个对象



        
        function example() {
            return {
                foo: "1",
                bar: "2",
                sos: "3",
            };
        }
        let { foo, bar, sos } = example();







    </script>
</body>

</html>