<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        const log = console.log.bind(console)
        const dir = console.dir.bind(console)



        // for (let i = 0; i < 10; i++) {
        //     // console.log(i);  0 -10
        // }

        // for (var i = 0; i < 10; i++) {
        //     // console.log(i); 0 -10
        // }

        // for (let i = 0; i < 10; i++) {
        //     
        // }
        // console.log(i); //未定义

        var a = [];
        // for (var i = 0; i < 10; i++) {
        //     a[i] = function () {
        //         console.log(i);
        //     };
        // }
        // a[6](); // 10



        for (let i = 0; i < 10; i++) {
            a[i] = function () {
                //console.log(i);
            };
        }
        a[6](); // 6


        // 猜想:不同层级的变量，能否读取不同层级的变量。

        // 1. 创建for循环 使用let关键字定义索引值.
        // 2. 在循环体内 利用var关键字定义函数，函数能否输出索引值。


        for (let i = 0; i < 10; i++) {
            var x1 = function () {
                log(i)
            }
        }
        x1()
        // 验证: 调用x1函数 能否输出使用let关键字定义 i的值。
        // 结论  即只要再for循环体内，就能输出i的值。


        // 进一步验证: 

        for (let i = 0; i < 10; i++) {
        }
        var x1 = function () {
            //log(i)
        }


        //x1()  // 无法输出i的值



        // 1.2 总结
        // 1. let是声明变量的关键字与var类似。
        // 2. 使用let声明的变量，只能在声明let的区块内使用，外部无法调用使用。
        // 3. 


        // 示例:

        var i = function () {
            let animal = "dog"; //未定义
        }

        //log(animal)  //未定义



        var i = function () {
            log(12)
            let animal = "dog"; //未定义
            log(animal)
        }
        i()


        // 描述你的问题.
        // 1. 使用var关键字定义一个函数.
        // 2. 在函数体内使用let声明一个变量，并log。
        // 3. 调用函数，无法输出变量。



        // 记录:
        // 进行验证与猜想的思考过程。
        // 在遇到问题的过程中的思考过程.



        // 


        var str = "abc"

        log(str.startsWith("a", 1))






        // 1.3 暂时性死区

        // var tmp = 123;

        // if (true) {
        //     tmp = 'abc'; // ReferenceError
        //     let tmp;
        // }

        var tmp = 123;

        if (true) {
            let tmp;
            tmp = 'abc';
            log(tmp)
        }



        // 在什么的情况下会触发暂时性死区。

        // if (true) {
        //     // TDZ开始
        //     tmp = 'abc'; // ReferenceError
        //     console.log(tmp); // ReferenceError

        //     let tmp; // TDZ结束
        //     console.log(tmp); // undefined

        //     tmp = 123;
        //     console.log(tmp); // 123
        // }


        // if (true) {
        //     // TDZ开始
        //     tmp = 'abc'; // ReferenceError
        //     console.log(tmp); // ReferenceError

        //     var tmp; // TDZ结束
        //     console.log(tmp); // undefined

        //     tmp = 123;
        //     console.log(tmp); // 123
        // }

        // 当一个代码块内使用了let声明变量，会触发暂时性死区。
        // 凡是声明变量之前的区块，都属于暂时性死区的范围，声明之后即结束。



        // 变量的作用:
        // 1. 参数
        // 2. 存储数据

        // 1.4 变量不允许重复声明

        // 在哪里还存在这种与之类似的特性

        // 报错
        // function func() {
        //     let a = 10;
        //     var a = 1;
        // }


        // // 报错
        // function func() {
        //     let a = 10;
        //     let a = 1;
        // }


        // 阮一峰老师根据这个特性得到的结论
        // 因此，不能在函数内部重新声明参数。

        // function func(num) {
        //     let num
        // }

        // // 报错


        // // 为什么会报错。

        // function func(num) {
        //     var num
        // }

        // 为什么这样不报错。




        // 解决问题的第一步，描述清晰的问题。
        // 1.定义函数设置一个参数
        // 2. 在函数体内用 var let 关键字重新声明参数 let 会报错 var 不会报错。

        //  为什么

        // 猜想与验证










        // 2.2 ES6 的块级作用域
        // 1. 为什么需要？
        //  2. 他的好处？
        // 2. 好处 代码块与代码块之间 不会互相影响，降低耦合度。
        // 这也是软件模块化的一个原则。
        //  3. 能否举一些实例？

        function f1() {
            let n = 5;
            if (true) {
                let n = 10;
            }
            console.log(n); // 5
        }


        // ES6 允许块级作用域的任意嵌套

        {
            {
                {
                    {
                        { let insane = 'Hello World' }
                        //console.log(insane); // 报错
                    }
                }
            }
        };

        // 一个花括号就是代表一个独立的块级作用域。



        // 内层作用域可以定义外层作用域的同名变量


        {
            { let insane = 'Hello World' }
            let insane = "hello1 world"
            console.log(insane);
        }




        // ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。






        // 总结一下




        // function sum() {

        //     log(x);
        //     let x;
        //     let x = 12;

            // let定义的变量名不存在变量提升，
            // 当变量未声明之前，都会触发暂时性死区，
            // let关键字声明的变量，



















    </script>
</body>

</html>