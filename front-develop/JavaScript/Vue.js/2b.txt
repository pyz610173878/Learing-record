00:00:00	哈尔滨工业大学 IBM技术中心&清影PT压制组
00:00:00	倾情制作
00:00:00	题记
00:00:00	现在到了数学抽象中最关键的一步：让我们忘记这些符号所表示的对象。
00:00:00	……（数学家）不应在这里停步，有许多操作可以应用与这些符号，而根本
00:00:00	不必考虑它们到底代表着什么东西。
00:00:00	——Hermann Weyl，思维的数学方式
00:00:04	计算机程序的构造和解释
00:00:04	字幕&时间轴 邓雄飞 (Dysprosium)
00:00:04	后期&压制 「     」
00:00:04	翻译 邓雄飞
00:00:04	特别感谢 裘宗燕教授
00:00:12	复合数据
00:00:21	到目前为止 这门课都在讨论过程
00:00:25	我想提醒大家 我们介绍的这个框架
00:00:29	是用来讨论语言的
00:00:30	我们讨论内建于系统中的基本元素
00:00:35	我们介绍了一些组合的方法
00:00:38	这些方法用来组合基本元素 使你能够构造更复杂的东西
00:00:42	然后我们讨论了抽象的方法
00:00:43	你如何去取用这些复杂的东西
00:00:46	给它们命名 这样就可以像简单单元那样使用
00:00:49	上节课最后 我们甚至做了更超前的东西
00:00:51	我们看到 通过使用高阶过程
00:00:55	我们甚至可以表达计算的通用方法
00:00:57	这就像求不动点的方法和牛顿法
00:01:02	你可以通过组合这些抽象的方法
00:01:05	来得到这种难以置信的表达力
00:01:08	这样做的中心点是
00:01:11	我们要构建一个层次系统
00:01:14	譬如说
00:01:16	如果我们编写平方根过程
00:01:20	而这个平方根过程又用到了一个叫GOOD-ENOUGH的过程
00:01:31	而这两者之间就有某种抽象屏障
00:01:37	这大概就像是我们开始编写平方根程序
00:01:40	先要与George订好“契约”
00:01:44	告诉他 他的工作是编写GOOD-ENOUGH过程
00:01:48	因此只要GOOD-ENOUGH按我们的预期运作
00:01:50	我们就不管它是如何运作的
00:01:52	我们不关心（它的内部）实现
00:01:54	实现层面是Goerge操心的 和我们无关
00:02:00	又比如
00:02:00	George可能用了Harry写的绝对值过程
00:02:06	但我们不会去关心这些
00:02:07	我们甚至可能还不知道有Harry这号人
00:02:13	关键就是 当我们在构造东西时
00:02:16	我们将构造整体的任务划分为了实现部件的任务
00:02:26	当然 在一个大型系统中
00:02:28	我们有像这样的抽象屏障
00:02:30	在很高很高很高层次上的抽象屏障
00:02:33	这也是我们到目前为止一直在使用的思想
00:02:35	贯彻到每次编写过程之中
00:02:37	言归正传 我们将要在数据中看到同样的问题
00:02:43	我们发现系统中有基本数据
00:02:46	实际上我们已经注意了
00:02:47	我们已经讨论了作为基本对象的数
00:02:49	我们将看到适用于数据的组合方法
00:02:52	有一种“胶水” 能让你把基本数据粘合在一起
00:02:56	来构造一种更复杂的符合数据
00:02:59	然后我们将看到一种抽象方法学
00:03:04	这种方法十分好用 尤其是
00:03:06	当你用简易的数据构造复杂数据时
00:03:08	再次强调 中心思想是要建立层次化的系统
00:03:13	建立抽象屏障将细节隔离在底层
00:03:19	将细节与你所工作的高层环境隔离开
00:03:21	底层的细节 底层的思想 都不重要
00:03:24	那是George该操心的
00:03:26	因为他跟我们“订好契约”
00:03:28	他负责实现这些行为
00:03:31	怎么实现都是他的事
00:03:35	好了 来看一个实例吧
00:03:37	我们将会讨论一个系统
00:03:40	一个在有理数域上做算术运算的系统
00:03:42	我现在所想到的是
00:03:44	计算机中应该有某种东西
00:03:46	使得我们可以查询
00:03:50	类似于 1/2加上1/4的和是多少
00:03:55	系统说 是3/4
00:04:02	我们也可以查询3/4乘以2/3的积
00:04:10	系统因该能够回答 结果是1/2
00:04:16	对吧？ 你知道我想表达的意思
00:04:17	我不太确定你们是多久掌握这些运算的
00:04:20	五年级或者六年级吧？
00:04:21	这里的一些公式说
00:04:23	如果有形式为分子除以分母的分数
00:04:28	而如果我要将这个分数与另一个分数相加的话
00:04:31	当然 这个分数也是分子除以分母
00:04:34	那么结果将会是 第一个分数的分子
00:04:39	乘以第二个分数的分母
00:04:41	加上第二个分数的分子乘以第一个分数的分母
00:04:48	当然 这只是答案的分子
00:04:49	答案的分母是两个分数的分母之积
00:04:52	对吧？ 这大概就是五、六年级课程的分数算术
00:04:57	类似地 如果我想要将两个数乘起来
00:04:59	N1除以D1的商 乘以 N2除以D2的商
00:05:05	就是两个分数的分子之积除以两个分母之积的商
00:05:14	所以这些都不构成问题
00:05:16	当然 理解这些
00:05:18	你想进行的分数运算
00:05:20	是完全没问题的
00:05:23	但是当我们实现这个功能的时候 我们似乎遗漏了什么
00:05:27	我们连有理数都没有
00:05:32	系统只提供给我们了单个数字 比如5和3
00:05:38	但我们没法去表达
00:05:43	一个同时具有3和4的东西
00:05:47	或者同时具有2和3的东西
00:05:49	但只要我们去想象
00:05:53	我们就会看到一些云彩
00:05:57	某个云彩不知咋的就有分子和分母
00:06:02	这就是我们想让拥有的功能
00:06:06	那么 我们要怎么解决这个问题呢？
00:06:07	我们将使用一种强大的设计策略来解决这个问题
00:06:13	这种策略我们已经反复使用过了
00:06:16	这就是按愿望思维的策略
00:06:25	假设现在还没有任何过程
00:06:27	我们就想象确实存在着某个过程
00:06:30	那么 我们就来想象我们有了这些（有理数）云彩吧
00:06:35	更准确一点来说
00:06:38	让我们假设我们有了三个过程
00:06:43	其一为MAKE-RAT
00:06:47	MAKE-RAT有两个参数
00:06:54	我们分别把它们叫作分子和分母
00:06:57	它给我们返回一朵——我们需要的云彩
00:07:04	我并不知道云彩是什么
00:07:06	无论MAKE-RAT返回什么 那都是它的事
00:07:11	并且我们会说
00:07:12	假设我们有了这样的一个云彩
00:07:13	我们有个叫NUMER的过程
00:07:16	这个过程需要我们传递具有N和D的云彩
00:07:19	不管这个云彩是什么 我也不知道这个云彩是什么
00:07:22	但NUMER过程会返回（云彩的）分子部分
00:07:26	我们也会假设我们有个叫DENOM的过程
00:07:30	该过程需要我们传递一个云彩 不管云彩是什么
00:07:34	并返回（云彩的）分母部分
00:07:37	就像之前我们构造平方根过程一样
00:07:42	我们假设我们有GOOD-ENOUGH过程
00:07:45	对吧？ 我们会找到George 对他说
00:07:48	那么 你的任务就是实现这三个过程
00:07:51	你选择如何实现这些云彩 就是你的事了
00:07:54	我们不想深究
00:07:58	这样 把这些杂事都推给George后
00:08:03	完成其它部分就相当容易了
00:08:05	一旦我们有了这些云彩后 编写那些
00:08:08	把有理数加起来的程序就变得容易多了
00:08:11	你可以定义 这么说吧 定义+RAT
00:08:22	定义+RAT过程 该过程需要两个有理数参数 X和Y
00:08:27	X和Y就是这些云彩
00:08:31	这个过程干些啥呢？
00:08:32	它将返回给我们一个有理数
00:08:39	这个有理数是怎么得来的呢？
00:08:41	依据这里的公式
00:08:43	答案的分子的一部分为
00:08:47	X的分子与Y的分母之积
00:09:02	这只是答案的分子的一部分
00:09:03	结果的分子剩下的一部分是
00:09:06	Y的分子与X的分母之积
00:09:18	闭合* 闭合+
00:09:20	好了 这是MAKE-RAT的第一个参数
00:09:23	这是我将要构造的云彩的分子
00:09:26	而MAKE-RAT剩下的参数
00:09:28	则是答案的分母
00:09:30	也就是X的分母乘以Y的分母
00:09:41	像这样
00:09:45	好 这就是对有理数加法的一个模拟
00:09:51	在假设我们有了这些云彩后 就变得完全没有问题
00:09:59	当然 我们可以用同样的方法把它们乘起来
00:10:05	我们把将两个有理数乘起来定义为*RAT过程
00:10:12	该过程需要两朵云彩 X和Y
00:10:19	返回一个用MAKE-RAT构造的有理数
00:10:24	这个有理数的分子是
00:10:30	X的分子与Y的分子之积
00:10:37	而这个有理数的分母则是
00:10:41	X的分母与Y的分母之积
00:10:57	好了 现在就差告诉你这些云彩是什么了
00:11:02	所有操作都是围绕它展开的 看到我做了什么吗？
00:11:04	我按照我的愿望假设我有一种新的数据类型
00:11:09	特别地 我假设我有创建这些数据类型的能力
00:11:15	这里的MAKE-RAT就创建了一个新的数据类型
00:11:17	这叫作“构造函数”
00:11:25	我现在有了可以构造这些数据类型的东西了
00:11:29	然后我假设我有某些东西 有了这些东西后
00:11:34	我就有从中抽取部分信息的方法了 这些叫作“选择函数”
00:11:42	说得更正式一点 就是说
00:11:44	我假设有了用于处理这些数据类型的构造函数和选择函数
00:11:48	我就可以靠它们来编程了
00:11:51	这就好比我说假设我有GOOD-ENOUGH?过程
00:11:56	并用它来实现平方根这种做法
00:12:00	好 在我们继续之前
00:12:04	让我们来想想 为什么我们首先就在这个地方实现了这些东西？
00:12:08	为什么我们需要一个像+RAT这样的过程
00:12:13	一个需要两个有理数作为参数并返回一个有理数的过程
00:12:19	换一种想法就是 我们实现的是这里的这个公式
00:12:24	这里我也实现了用于加和两个有理数的东西
00:12:29	再换一种想法就是 这有这么一个东西
00:12:31	可以让我输入四个数 N1 D1 N2 D2
00:12:36	然后这个东西就修改机器里的寄存器
00:12:38	来代表分子和分母
00:12:42	所以你大概会问
00:12:43	你为什么不用四个分别代表分子和分母的数
00:12:45	来做有理数加法
00:12:46	这个加法返回两个数 分别代表分子和分母
00:12:50	我们为什么要像这样构造“云彩”？
00:12:58	呃 那是因为
00:12:59	假设你想表达像这样的东西
00:13:05	假设我想表达让两个有理数
00:13:12	X加Y的和 乘以 另外两个有理数S、T的和
00:13:23	然而 当我有了像+RAT和*RAT这样的东西后
00:13:28	我就会将其考虑为乘积
00:13:33	就是将*RAT应用于X和Y的和以及S和T的和上
00:13:51	我就得到了一个表达式 如果不考虑语法的话
00:13:55	这个表达式看起来像是按照数学思想表达的
00:13:59	我说这有两个数 这个东西代表了这两个数的和
00:14:05	然而这个东西又代表了另两个数的和
00:14:08	就是这个和这个
00:14:10	然后我把它们乘起来
00:14:12	所以我有了一个和这里的表达式相匹配的表达式
00:14:14	而如果我用其它的方式去表达 我说
00:14:16	我向机器传递四个数
00:14:20	四个分别代表X和Y的分子、分母的数
00:14:23	然后又是四个分别代表S和T的分子、分母的数
00:14:28	我现在又该干什么呢？
00:14:31	我把这些加起来 然后我们就得到了两个临时变量
00:14:35	分别代表了和的分子、分母
00:14:37	我又得去找个地方把它们存储起来
00:14:42	然后到了这里 我又传入了四个数
00:14:44	我得到了两个临时变量
00:14:46	分别代表了S和T之和的分子和分母
00:14:49	最后 我通过把它们乘起来来将其结合在一起
00:14:54	如你所见 麻烦出来了
00:14:56	这里满是临时变量
00:14:58	这些应该是这些有理数内部的“内脏”吧
00:15:02	但却显露在我们的系统中
00:15:05	当然 随着表达式变得越来越复杂
00:15:08	这些“内脏”就会显露得越来越多 使我编程时感到困惑
00:15:12	像这样写程序的人
00:15:15	你只是在用汇编语言的思想来加和两数
00:15:18	你也发现 你突然之间需要关注这些临时变量了
00:15:22	而这些对我大脑造成的困惑 要比对编程造成的困惑更严重
00:15:29	而编程的本质就是
00:15:33	我们希望程序设计语言能够表达
00:15:36	我们脑中的概念
00:15:39	有理数就是这些概念
00:15:42	我们可以先把它们加起来然后再乘起来
00:15:48	有疑问吗？
00:15:57	恩
00:15:59	学生：我不太明白为什么
00:16:01	我们既然有MAKE-RAT过程了
00:16:04	我们传递两个参数作为分子和分母来构造一朵云彩
00:16:08	但最后我们又从中将这些东西原原本本地给抽取出来
00:16:11	教授：是这样的
00:16:13	我们的问题是 既然我们是用分子和分母构造云彩
00:16:17	但我为什么又想从云彩里面把它们取出来呢？
00:16:23	这个是我在后面提到过的 不过让先说下吧
00:16:26	这个问题非常关键
00:16:29	关键点就是 我想让分子和分母
00:16:34	总是在绑一起
00:16:36	我完完全全知道
00:16:38	这里面有分子和分母
00:16:40	同样的 我也想表达
00:16:45	但是 从另一个角度来看 这就是X
00:16:49	我可以取用X 我给它命名为X 我就可以控制它了
00:16:52	然后我就可以说 X加上Y的和
00:16:55	我只考虑一个X的时候 使用两个数来代表分子、分母并无大碍
00:16:59	但是当我有10个有理数时
00:17:01	如果我不把它们联系起来
00:17:03	我一下子就有了20个不必要的分子和分母
00:17:06	它们只是20个没有以一种特定方式联系起来的任意数而已
00:17:10	这就像是说
00:17:13	我要把这些过程体的指令
00:17:15	把它们封装起来作为一个过程
00:17:17	这是一码子事儿
00:17:30	没问题了 好吧
00:17:34	那休息一下 活动一下吧 [听不清]
00:17:37	[音乐]
00:17:45	《计算机程序的构造和解释》
00:17:50	讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
00:18:09	《计算机程序的构造和解释》
00:18:18	复合数据
00:18:26	好吧 回到我们的有理数算术系统来
00:18:31	而我们做的 最重要的是
00:18:35	我们我们把这个问题分解为了两部分
00:18:39	我们假设跟George“订好契约”
00:18:43	George已经给出了如何去构造这些云彩
00:18:47	他向我们提供了一个作为构造函数的MAKE-RAT过程
00:18:51	相应的 用于提取分子和分母的选择函数
00:18:54	然后 我们用这些东西
00:18:55	我们实现了有理数的加法和乘法
00:19:00	好了 我们来看看George面临的问题吧
00:19:03	我们如何来把分子和分母给封装起来
00:19:07	并把它们放在“云彩”里
00:19:09	我们需要的是一种胶水
00:19:12	一种可以让我们把数据结合在一起的胶水
00:19:17	幸而Lisp提供了这样的胶水
00:19:21	我们把它叫作“表结构”
00:19:30	表结构是一种将数据粘合在一起的工具
00:19:35	说得更准确一点
00:19:36	就是Lisp提供了一种构造序对的方法
00:19:44	Lisp里面有一个叫CONS的基本过程
00:19:52	让我们来看一下
00:19:54	这个就是CONS
00:19:59	CONS是一个运算符 它需要两个参数X和Y
00:20:06	它返回给我们一种叫作“序对”的东西
00:20:11	而所谓的“序对” 就是具有“首部分”和“次部分”
00:20:21	这也解释了为什么CONS需要两个参数
00:20:25	如果我们有一个序对的话
00:20:26	X就是首部分 而Y就是次部分
00:20:31	这就是它的构造方式
00:20:33	我们同样也有把东西取出来的方法
00:20:36	给定一个序对 我们有一个叫CAR的东西
00:20:41	使得 序对P的CAR就是序对P的首部分
00:20:46	也有一个叫CDR的东西
00:20:47	使得序对P的CDR 就是序对P的次部分
00:20:54	这些就是我们构造数据的方法
00:20:56	在将这些数据用图画表示时 我们也有一种俗成的方法
00:21:02	这类似于我们用俗成的方法书写柏拉图概念下的2
00:21:13	我们像这样画个图来表示 (CONS 2 3)
00:21:21	先画个小盒子
00:21:23	这个就是我们讨论的（序对）
00:21:26	盒子“放出”两个箭头
00:21:29	我们说 这个序对的首部分是2
00:21:34	而这个序对的次部分是3
00:21:37	这种记法叫作“盒子—指针”记法
00:21:55	顺带一提 我现在就来说说
00:21:57	困惑了很多人的一点
00:21:58	我画这些指针时 重要的仅仅是指针的指向
00:22:03	一些人可能会认为 如果我这样画箭头
00:22:05	并把3放在这里 结果会不一样
00:22:08	这实际上是没区别的 能理解吗？
00:22:11	只不过是在这一大堆的箭头、指针和盒子中
00:22:14	唯一的区别就在于它们是如何联接的
00:22:16	而不是我把它们怎么放置 譬如向上放 向下放 或者交叉放
00:22:23	关于它们为什么叫做表结构
00:22:25	或许现在就完全不清楚了
00:22:28	我们今天不会讨论这个问题 我们下次再讨论吧
00:22:37	所以 我们可以用CONS构造序对
00:22:41	我准确地知道CONS、CAR和CDR的行为是
00:22:45	如果我有任意的X和Y
00:22:50	对任意的X和Y
00:22:53	我可以用CONS来构造一个序对
00:22:59	那么该序对的CAR就是X 就是我的构造时的一个输入
00:23:03	而该序对的CDR就是Y
00:23:07	这就是CONS、CAR、CDR这些运算符的行为
00:23:12	有了这些东西 George构造有理数就明了多了
00:23:17	言归正传 George要——
00:23:19	记得吗 George的任务是实现MAKE-RAT、NUMER、DENOM过程
00:23:23	George这样编写代码  (DEFINE (MAKE-RAT N D)
00:23:36	就是将CONS应用于这二者
00:23:40	也就是(CONS N D)
00:23:45	而如果我想取出分子
00:23:47	代码我这样写 (DEFINE (NUMER X)
00:23:59	如果我们是用序对来实现有理数的话
00:24:02	我只需要用CAR来获得X的首部分
00:24:06	类似的 DENOM就是用CDR运算符了
00:24:19	也就是我用于构造序对的另一个数据
00:24:26	我们现在就是在干这件事
00:24:28	这就是有理数的一种实现
00:24:33	我们来实践一下 假设我想要
00:24:35	我想要求取1/2加上1/4 并观察系统是怎么运作的
00:24:43	那么 我或许会定义一个A
00:24:50	我需要构造一个1/2
00:24:52	也就是一个分子为1 分母为2的有理数
00:24:59	也就是 A为(MAKE-RAT 1 2)
00:25:05	然后我来构造1/4
00:25:07	我定义B为(MAKE-RAT 1 4)
00:25:23	如果我想解得答案的话
00:25:25	先假设我们没有一个专门用于打印有理数的东西
00:25:28	我可以自己编写一个
00:25:29	比如说 我可以这样写
00:25:31	定义答案为(+RAT A B)
00:25:45	那么我就可以问 答案是多少？
00:25:47	答案的分子和分母分别是多少？
00:25:50	因此 我把1/2和1/4加起来后 我会问 答案的分子是多少？
00:26:03	系统就就会打印出 6
00:26:10	糟糕了
00:26:12	而如果我问答案的分母是多少
00:26:22	系统就就会打印出8
00:26:26	我们本来希望能得到
00:26:29	1/2加1/4是3/4
00:26:35	但这台愚蠢的机器却说 不 应该是6/8
00:26:40	恩 这的确有点糟糕
00:26:43	问题在哪里呢？
00:26:46	是什么导致的呢？
00:26:48	问题出在+RAT上
00:26:51	+RAT只是把A的分子和B分母之积与
00:26:57	B的分子和A的分母之积加在一起
00:27:00	并把它们除以两分母之积
00:27:02	这就是为什么得到6/8的原因
00:27:05	那么 我们的+RAT实现有什么问题呢？
00:27:10	我们在此之前所做的有理数算术又有什么错误呢？
00:27:15	当然 从一方面来看 这一点都没有错
00:27:19	这其实是一个相当好的实现
00:27:21	这个实现完完全全遵守了分数加法法则
00:27:29	我们可以这样说 这就是George的问题了
00:27:32	如果George只是简单地通过把分子和分母放在一起
00:27:37	来构造有理数的话 岂不是站不住脚？
00:27:42	在构造有理数时 如果George把这些东西化到最简
00:27:47	难道不是会跟好一点吗？
00:27:51	我想说的是 对George来说
00:27:55	用这个版本的MAKE-RAT 难道会比幻灯片上的这个好么？
00:28:03	不是简单地通过CONS 把N和D结合起来
00:28:07	我们先寻找N和D的最大公约数
00:28:12	我们用GCD过程来找
00:28:14	我们只需知道GCD是一个基本过程
00:28:16	它返回的是两个数的最大公约数
00:28:20	因此 这种构造有理数的方法就是
00:28:24	先找到两数的最大公约数
00:28:26	先用G来表示吧
00:28:29	不是简单通过CONS结合N、D 而是先让它们除以G
00:28:33	然后我再用CONS结合N/G和D/G的商
00:28:40	这样就把我们的有理数化到了最简
00:28:43	因此 当我在做加法时 当+RAT调用MAKE-RAT过程时
00:28:53	+RAT的定义里面有对MAKE-RAT的调用
00:28:57	因此 当+RAT构造有理数时
00:28:59	MAKE-RAT就自动将其化为最简了
00:29:08	好了 这就是一个完整的系统
00:29:14	让我们来看看我们完成的这个有理数算术系统吧
00:29:19	好吧 我们说过我们想要构造一个有理数算术系统
00:29:25	我们实现了+RAT
00:29:29	我也给你们展示了*RAT的实现
00:29:34	虽然我并没有去实现-RAT
00:29:35	就姑且假设我们实现了-RAT吧
00:29:38	事实上有些东西我并不知道
00:29:40	比如通过除法来判断相等
00:29:42	或者用某种特定方式打印有理数的函数
00:29:45	我们用序对的方式实现了它们
00:29:52	序对、CONS、CAR和CDR 这些都是内建于Lisp中的
00:29:55	而两者之间最重要的则是 这个和这个
00:30:04	我们在其间构筑了一道抽象屏障 一个抽象层
00:30:16	那么 “抽象层”又是什么呢？
00:30:18	准确的说 构造函数和选择函数就是抽象层
00:30:25	MAKE-RAT、NUMER、DENOM就是抽象层
00:30:38	这种方法学 也就是我们的做法
00:30:43	就是“分离” 分离对象的使用方法
00:30:53	我们把数据对象的使用
00:30:56	和它们的表示分离开来
00:31:07	就目前来说 我们有了使用有理数做计算的方法
00:31:12	在这儿 我们有它们表示的方法
00:31:14	它们通过这条边界分隔开
00:31:17	这条边界就是构造函数和选择函数
00:31:23	这种方法学有个名字
00:31:25	叫做数据抽象
00:31:35	数据抽象是一种通过假定的构造函数和选择函数将数据对象
00:31:39	与它的表示分隔开来的编程方法学
00:31:47	我们也完全可以不这样做 这又有什么干系呢？
00:31:51	当然就算不用任何复合对象
00:31:55	做有理数加法也是完全可行的
00:31:56	幻灯片上就是一个例子
00:31:59	我们当然可以这样定义+RAT
00:32:02	它需要两个参数X和Y
00:32:05	而我们会问 这些有理数到底是什么呢？
00:32:09	实质上 它们只是序对
00:32:11	分子是序对的CAR部分 分母是CDR部分
00:32:14	我们要做的 就是取出X的CAR部分乘以Y的CDR部分
00:32:21	并把它们乘起来
00:32:23	取出Y的CAR部分和CDR部分相乘 再与之前的结果相加
00:32:28	取出X的CDR部分乘以Y的CDR部分
00:32:31	并把最终结果构造起来
00:32:33	这其实是一样的
00:32:41	但这种方法忽略了把对象归约到最低阶项的问题
00:32:44	让我们花点时间 仔细思考一下
00:32:47	我们为什么不这样做呢？
00:32:50	对吧 毕竟这样看起来会少定义很多过程
00:32:52	并且更加直白
00:32:55	它省去了很多我们关于“数据抽象”的“自以为是”的方法
00:33:00	而我们就不是这样做的
00:33:01	我的意思是这样或许会稍微高效一点
00:33:04	如果我们用的编译器对此有优化的话
00:33:07	而将数据的使用与表示分离开来的意图是什么呢？
00:33:13	这就将回到命名的记号了
00:33:16	还记得吗 编程中最重要的原理
00:33:21	和魔法中最重要的原理是一样的 对吧？
00:33:25	如果你知道某个精灵的名字 你就可以控制它
00:33:30	如果你回过头来看幻灯片
00:33:33	你会发现这里我们就有一个+RAT
00:33:36	如果我们有+RAT -RAT *RAT 或者和这些类似的过程
00:33:40	但在这个系统的任何地方
00:33:42	我无法找出任何一个有理数
00:33:53	在像这样的一个系统中 我并没有
00:33:56	没有一个有理数的概念实体
00:34:01	那么 这样做的优势是什么呢？
00:34:03	把有理数的概念和实体分离开来
00:34:08	然后用MAKE-RAT、NUMER、DENOM来控制它们有什么优势么？
00:34:13	优势之一就是你可以使用其它的方法表示（数据）
00:34:20	之前我不是给你们看过
00:34:24	George解决分数化简的方法么？
00:34:26	当他在构建有理数时
00:34:28	将分子分母同时除以最大公约数
00:34:30	另一种解决办法在这里
00:34:36	我可以用另一种方法表示有理数
00:34:39	也就是直接使用CONS来构建有理数
00:34:43	而当你在析取去分子时
00:34:45	在那个时候再计算分子分母的最大公约数
00:34:52	然后再用分子除以这个最大公约数
00:34:57	类似地 当我析取分母时
00:35:00	当我在析取出分母时 我将它除以最大公约数
00:35:05	所以在旧的表示法中
00:35:08	当ANS在这里被构造时
00:35:11	在第一种方法中 也就是6和8
00:35:14	在6和8被装入表中时 它们已经被化到最简
00:35:16	析取分子会得到3
00:35:20	而在我给你们展示的方法中
00:35:21	我们放入的是6和8
00:35:24	然后在我析取分子时会进行一些计算
00:35:27	使得我得到3而非6
00:35:32	这就是我可以使用的两种不同方法
00:35:33	哪种更好呢？
00:35:37	这得看情况 对吧？
00:35:38	如果我的系统中我经常构造有理数
00:35:41	而不常去析取它们
00:35:42	那么早构造它们时就最好不要化简
00:35:47	如果在我的系统中 比起构造 我更经常去析取它们
00:35:51	那在构造时就将它们化简就一劳永逸了
00:35:56	这得视情况做出选择
00:35:58	但真正的问题是 在你实现这些有理数时
00:36:04	没法决定要用哪种表示法
00:36:07	通常来说 作为一名系统设计师
00:36:13	你被强迫去做出 关于如何解决问题的决定
00:36:17	通常来说 你用于保持系统弹性的方法
00:36:20	就是在你被迫做出决定前不要做任何事
00:36:26	但问题是 在推迟决定和彻底推延之间
00:36:31	并没有太明显的界限
00:36:38	你想要继续前进 但与此同时
00:36:43	你也希望不要被你决定的结果给限制住
00:36:48	数据抽象就是解决方法之一
00:36:50	我的做的就是“按愿望思维”
00:36:54	我们给结果命了个名字
00:36:56	我们让MAKE-RAT、NUMER、DENOM代表它们运作的结果
00:37:02	但它们如何运作则是George的事
00:37:03	实际上 我们只是用几个名字代表我们期望运作的结果
00:37:09	然后继续编程 就像我们的确得到了结果
00:37:13	到了最后 我们确实必须计算它时
00:37:16	再回过头来完成必要的计算
00:37:20	事实上从现在起 我们将会三番五次地看到
00:37:22	我们不会非得选定一个特定的表示方式 从来都不会
00:37:27	不管如何 这都是一种非常有用的设计技术
00:37:30	这也是人们使用数据抽象的原因
00:37:34	我们会不断的看到这个理念
00:37:38	有什么问题吗？
00:37:40	学生：通过抽象层做出决定与
00:37:44	编码前做完成设计的信条相比 哪个更好呢？
00:37:49	教授：这只是少数人的信条
00:37:51	我打赌这是那些不经常实现大型计算机系统的家伙的信条
00:38:00	我曾说过计算机科学非常像魔法
00:38:03	像魔法这一点非常好
00:38:05	但是计算机科学也非常像宗教 这就不好了
00:38:08	通常来说 我认为那些相信在编码前就能把系统设计完美
00:38:15	大多都是一些没有设计过大规模系统的人
00:38:20	我们的方法 厉害之处就在于可以假设我们已经得到结果了
00:38:25	然后再讨论到底是哪个是对的
00:38:28	或者你应该得到怎样的结果
00:38:30	当你学会这招了 你会发现这个是最棒的一招
00:38:35	学生：您能解释一下LET和DEFINE的区别吗？
00:38:39	教授：好的
00:38:41	LET是用来建立一个局部的名字
00:38:53	嗯 我就先大概给你说下
00:38:57	然后我们再来讨论这整个复杂的过程
00:39:02	就现在来说 区别就在于 当你在Lisp中编程时
00:39:07	编写定义是与所在环境有关的
00:39:11	当你想把A定义为5时 我写(DEFINE A 5)
00:39:20	从此以后我们就会记得A就是5
00:39:25	LET会建立一个包含一个定义的局部上下文
00:39:30	所以当我键入 比如(LET ((A
00:39:36	或者我写(LET ((Z 10)))
00:39:48	然后在这个上下文中 我们计算Z加上Z的和
00:39:54	如果我在Lisp中这样写的话
00:39:58	Lisp会输出20
00:40:01	然而 如果我再问Z是什么
00:40:06	计算机会告诉我Z是一个未绑定的变量
00:40:10	因此LET可以创建一个上下文 你可以在这个上下文中进行定义
00:40:15	但是这些都是这个上下文中的局部定义
00:40:19	当然啦 我把这个改为A的话 我依旧会得到20
00:40:27	但是这个A与这个A一点也不冲突
00:40:33	所以我键入这个 再键入这个 再问A是什么
00:40:36	A还会是5
00:40:39	因此在LET和DEFINE之间有这另一种代换模型
00:40:42	但这（LET的有效域是局部的）才是最重要的
00:40:44	[音乐]
00:41:03	《计算机程序的构造和解释》
00:41:07	讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
00:41:11	复合数据
00:41:19	好了 我们已经看过作为数据抽象技术的示例
00:41:23	在有理数域上做算术的小型系统的实现
00:41:30	这就是一种在大型系统中控制复杂度的方法
00:41:36	就像定义过程
00:41:38	以及我们谈论的所有的控制复杂度的方法
00:41:41	这些东西的真正厉害之处不是体现在实现它们本身
00:41:47	我们构建的有理数运算系统并不是什么了不起的事
00:41:52	而是你可以将这些东西用于构建更复杂的东西
00:42:00	你把两个数放在一起构成一个序对 这也一点不新奇
00:42:04	如果你真想那么做的话
00:42:05	我们有各式各样的方法
00:42:08	我们的问题是 我们能否找到一种方法
00:42:11	可以让我们构建的东西作为一个块
00:42:12	用来构建更复杂的东西？
00:42:16	因此无论何时有人向你展示控制复杂度的方法
00:42:19	你都应该说 嗯 这很不错 但我可以用它来构建什么呢？
00:42:24	举个例子吧
00:42:27	我举一个很像刚才那个有理数系统的例子
00:42:31	假设我们想要在平面中表示一个点
00:42:35	好吧 这里有一个点
00:42:37	我们把它叫做点P
00:42:40	这个点可能会有一个坐标
00:42:47	比如点P就是(1,2)
00:42:50	X坐标为1 Y坐标为2
00:42:54	我们将要构建一个用于在平面中处理这些点的小型系统
00:43:00	我们当然可以 可以像这样
00:43:06	用向量来表示 就和点在平面中的表示是一样的
00:43:09	我们也会说 嗯
00:43:11	这里有一个叫做MAKE-VERCTOR的构造函数
00:43:17	函数MAKE-VERCTOR需要两个坐标
00:43:20	当然 如果我们愿意的话可以将其实现为序对
00:43:23	但是最重点的是我们有一个构造函数
00:43:26	当我们传递了向量P后
00:43:29	我们可以得到它的X坐标
00:43:31	我们也可以得到它的Y坐标
00:43:33	所以这里就有了点在平面系统中的构造函数和选择函数
00:43:38	那么 我们有了平面中的点 就希望将它们用来构建事物
00:43:42	比如说 我们想要
00:43:44	我们有一个点P 一个点Q
00:43:48	点P为(1,2) 点Q为(2,3)
00:43:54	我们想要得到从P开始 到Q截止的线段
00:44:01	我们把它叫做线段S
00:44:04	我们想用数字来表示点 并用点来构造向量
00:44:12	用向量来表示线段
00:44:16	因此我们也可以对线段如法炮制
00:44:19	因此 对于从P到Q的线段
00:44:21	我们这里有一个构造函数MAKE-SEGMENT
00:44:26	然后是为选择函数取名
00:44:29	取得线段起点的函数 和取得终点的函数
00:44:32	当然了 我们可以将线段实现为两个点构造成的序对
00:44:36	CAR和CDR可以分别取得构成线段的两个点
00:44:44	好了 我们已经完成这个系统了
00:44:47	我们可以进行一些此操作
00:44:51	比如说 某个线段的中点是什么？
00:44:57	这就是某个线段的中点
00:44:59	该点的X、Y坐标分别为起点和终点X、Y坐标和的一半
00:45:07	嗯 这就是中点
00:45:09	因此 为了得到线段S的中点
00:45:13	我们先要取得该线段的起点
00:45:17	取得该线段的终点
00:45:19	然后构建一个向量 也就是一个点
00:45:22	该点的X坐标为起点、终点X坐标和的一半
00:45:29	Y坐标为起点、终点Y坐标和的一半
00:45:33	这就是函数MIDPOINT一种实现
00:45:37	类似的 我们可以编写类似于求取线段长度的函数
00:45:43	线段的长度 可以根据勾股定理算得
00:45:51	线段的长度是dX的平方加dY的平方的和的平方根
00:45:56	当我们说计算某线段S的长度时
00:45:59	我们令dX为起点、终点X坐标之差
00:46:11	令dY为起点、终点Y坐标之差
00:46:15	然后我们求取dX、dY平方和的平方根
00:46:19	就是这样了
00:46:22	好了 这就是函数LENGTH的一种实现
00:46:25	再次强调 我们构建的是一种层次系统
00:46:35	我们构建了一个有 呃 现在有线段
00:46:47	这里就有了一道抽象屏障
00:46:50	这道抽象屏障把
00:46:56	线段同向量、点的实现分离开来
00:46:59	而这道抽象屏障 就是构造函数和选择函数
00:47:03	也就是 MAKE-SEG SEG-START 和 SEG-END
00:47:17	这里是向量
00:47:19	而向量则是建立在序对和数的基础上
00:47:25	所以这里是序对和数
00:47:29	这又是它们的抽象屏障
00:47:32	也就是 MAKE-VECT XCOR 和 YCOR
00:47:46	如此可见 这就是一个层次系统
00:47:48	你可以清楚的看出这些分明的层次
00:47:51	我提一下 这里有一个非常重要但是又理所当然的东西
00:48:00	这点非常自然 但从另外一方面来说又非常重要
00:48:07	我们为了表示某线段S
00:48:11	我说这个线段就是由点构成的序对
00:48:16	而一个点又是由数构成的序对
00:48:18	如果要把这个结构的盒子—指针模型给画出来的话
00:48:23	那么我会说 嗯 这个线段是
00:48:26	用我之前给你们说过的表示法来演示
00:48:29	线段就是一个序对
00:48:33	序对的第一个元素是一个向量
00:48:40	向量是由数构成的序对
00:48:45	这就是它 这就是点P
00:48:49	线段中的另一个东西就是点Q
00:48:52	它本身就是一个由数构成的序对
00:48:59	当我说CONS可以让你把东西组合在一起的时候
00:49:03	就把它视作理所当然了
00:49:08	但有一点也很容易搞不明白 请注意
00:49:13	我也可以把一些序对给组合在一起
00:49:20	我以后会经常用一个术语来表示
00:49:24	一个我最喜欢的术语 这称作“闭包”
00:49:30	这种所谓具有“闭包性质”的组合方法
00:49:36	就是哪些当你用它们把东西组合在一起时
00:49:39	这就像我们构建序对的时候
00:49:41	你可以继续用同样的方法把组合物继续进行组合
00:49:44	因此我不仅可以有由数构成的序对 也可有由序对构成的序对
00:49:51	比如说 在Fortran中的数组并不具有闭包性质
00:49:59	因为我可以有元素为数的数组
00:50:01	但不能有以数组为元素的数组
00:50:05	当某人给你展示组合的方法时
00:50:07	你也应该这样问 通过该种组合方法
00:50:12	构建出的东西是否封闭
00:50:18	如果序对仅仅只能是由数构成的序对的话 就不是那么有趣了
00:50:22	我并不能用它构建出太多的结构
00:50:26	好了 言归正传
00:50:28	我现在只是提一下 后面我们还会详细讨论
00:50:31	你也可以看到在我们有了层次系统后 如果不使用数据抽象
00:50:38	系统复杂度会有失控的隐患
00:50:43	让我们回过头来看看LENGTH函数的幻灯片
00:50:47	LENGTH函数简单而有效是因为
00:50:52	当我使用它时 我确信
00:50:55	这个是第一个端点的X坐标
00:51:02	这些东西 这些选择函数 XCOR 和 SEG-END
00:51:07	都代表了一个决策选择 我不用关心它们的内部细节
00:51:11	因此就和之前的有理数系统一样 我可以说
00:51:16	我可以认为 嗯 线段实际上就是由序对构成的序对
00:51:20	线段第一个端点的X坐标实际上是什么 是什么呢？
00:51:27	它的线段的CAR部分的CAR部分
00:51:33	所以我可以这样完美地重定义LENGTH
00:51:37	我可以定义某线段S的长度为
00:51:48	我这样来写
00:51:50	我们令dX为 令dX为什么呢？
00:51:56	为两个坐标之差
00:51:57	坐标之一为(CAR (CAR S))
00:52:08	从第一个坐标中减去
00:52:11	减去另一个点的坐标 也就是(CAR (CDR S))
00:52:21	好了 那么dY也就是 我看看
00:52:25	那么Y坐标也就是 (CDR (CAR S))
00:52:34	减去(CDR (CDR S)) 诸如此类
00:52:43	你可以发现同之前那个程序相比 这个更难度
00:52:47	但比这个还糟的是 假设你这样实现了LENGTH函数
00:52:56	而第二天 George来和你说 抱歉 我改变主意了
00:53:00	我想把点的X坐标放在前面
00:53:04	然后您回过头来看代码 找啊找啊
00:53:06	那是什么呢 哦 是CAR
00:53:10	因此我要把这个改为CDR 把这个改为CDR
00:53:17	这个要改为CAR 这个也要改为CAR
00:53:23	你也就这么做了 然后第二天George又跑来说 抱歉 抱歉
00:53:27	设计显示的那个家伙想要让线段指向反方向
00:53:35	因此我必须让截止点放到第一位
00:53:37	然后你又回过头来审视这些代码
00:53:38	哦 这又改怎么弄？
00:53:42	嗯 把这个改为CDR
00:53:45	这个改为CAR 改为CAR 把这个改为CDR
00:53:50	你又这么做了
00:53:52	第二天 George又跑过来说 太抱歉了
00:53:53	我其实只是想让线段总是在屏幕上从左向右描绘
00:53:59	这时候 毫无疑问 你一定会给George一个耳光
00:54:03	正如你所见 一旦我们有了一个10层的系统
00:54:08	复杂度也就突增
00:54:11	甚至达到像这里一样失控的地步
00:54:15	因此 为了避免发生这样的事 我们就要为精灵命名
00:54:20	我们构建一个系统 这个系统中有一个
00:54:25	关于你要如何显示向量的选择
00:54:31	这个选择在这里
00:54:35	它们不必将其完全显露出来
00:54:37	就像这里你计算长度和中点
00:54:41	这才是这个系统真正强大之处
00:54:45	我们对它们很清楚 这样我们能控制它们
00:54:50	好了 有疑问吗？
00:54:51	学生：在那些无法使用序对来表示的情况中会如何呢？
00:54:55	比如说在三维空间里 一个序对无法表示三维坐标
00:55:01	也就是说在N维空间中 我们该如何做呢？
00:55:03	教授：啊 嗯
00:55:04	好吧 你提到了一点明天的内容
00:55:08	但关键点就是 一旦你有了二元的东西 就可以有多元的东西
00:55:16	能理解吗？ 如果我想要组合三个东西
00:55:19	我构建一个序对
00:55:24	该序对第一个元素是1
00:55:26	第二个元素则又是一个序对 一个有2和3的序对
00:55:34	以此类推 十个百个的东西 我可以把序对嵌套起来
00:55:37	这里 我相当随意地使用了一种方法
00:55:40	不久后你将看到更多地方法
00:55:42	而我们下节课将会讨论处理类似问题的约定
00:55:47	只要注意到我可以构建由序对构成的序对就好了
00:55:51	因为我只能构建由数构成的序对的话 我就没法了
00:56:06	好吧 休息
00:56:11	[音乐]
00:56:21	《计算机程序的构造和解释》
00:56:38	《计算机程序的构造和解释》
00:56:42	讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
00:56:46	复合数据
00:56:55	好吧 我们刚才只是做了
00:56:59	一个数据抽象的简单示例
00:57:03	现在我想做点更复杂的事儿
00:57:05	稍后我会详细说明这意味着什么
00:57:07	这也将更困难
00:57:08	因为在计算机程序设计中
00:57:12	说明某件事的的意义远比实现它难
00:57:16	让我们回到最最开始的地方
00:57:21	还记得当时我说过的话么？
00:57:25	我说 我们假设已经存在一些过程
00:57:29	MAKE-RAT、NUMER以及DENOM
00:57:38	好吧 我们就回到那里 回到最开始的地方
00:57:41	有构造函数和选择函数 以及定义有理数算术的地方
00:57:47	我那时说过 假设我们已经有了那些需要George实现的东西了
00:57:51	那么 在那个时候我们实际上干了什么呢？
00:57:55	做了些什么东西呢？
00:57:59	我想说的就是
00:58:00	我们用这些东西实现了有理数操作后又做了什么呢
00:58:05	我们用抽象数据来定义了有理数的表示
00:58:18	通过数据抽象我想表达什么？
00:58:20	关键点就是
00:58:24	在那个时候 当我们有了+RAT和*RAT
00:58:28	任何George提供给我们的MAKE-RAT NUMER和DENOM函数
00:58:37	都可以是有理数的表示基础
00:58:40	因为你并不应该关心
00:58:42	应该在那里获得最大公约数 等等
00:58:48	关键点就是 我们构建了一个有理数算术系统
00:58:53	一个可以基于任何表示方法的系统
00:58:56	“任何表示方法”又是什么意思呢？
00:58:59	我当然不会是指
00:59:01	George从一个包里面 随便取出3个过程
00:59:07	然后说 这就是那些实现
00:59:11	不是这样的
00:59:13	我指的是这里有一种衡量方法
00:59:20	可以判定这三个过程用于有理数的表示是否合适
00:59:25	如果我们仔细思考这个问题
00:59:28	我应该像这样定义 所谓的“合适”
00:59:31	我会说 如果X是(MAKR-RAT N D)
00:59:48	那么(NUMER X)除以(DENOM X)等同于N除以D
01:00:09	看到了吗 这就和George订的契约
01:00:13	而我们契约中订好的有理数规则
01:00:16	你仔细想想的话 也是正确的
01:00:18	我给你演示的这两个东西也是正确地
01:00:21	这样的话 就算我要考虑最大公约数
01:00:25	我除不除、在哪里除 都无所谓
01:00:28	因为我这里进行了约分
01:00:32	嗯 这就是George的契约
01:00:33	我们要告诉Georg的就是 提供给我三个过程
01:00:40	MAKE-RAT NUMER 和 DENOM
01:00:42	使得无论N和D如何选择 都可以满足这个契约
01:00:46	这也就是我所谓的我们可以用来作为有理数表示的基础
01:00:54	并且只要它们能满足契约
01:00:56	我们不关心他是如何实现的
01:00:59	这不关我们的事儿 这在抽象层之下
01:01:06	事实上 如果我们想知道 有理数真正是什么
01:01:13	那么 如果不在抽象层之下来讨论的话
01:01:16	我们必须得说有理数实际上是
01:01:23	这里的这些公理
01:01:25	就是MAKE-RAT NUMER 和 DENOM这三个满足这条公理的过程
01:01:32	从某种抽象的意义来说 这就是真正的有理数
01:01:41	这听起来很容易 因为你脑中已经有了
01:01:46	关于有理数是什么的知识
01:01:50	因为你已经看到了我们是如何构建有理数的
01:01:58	对 我们是在序对的基础上构建有理数的
01:02:08	因此 抽象地来说 我们可以认为有理数实际上就是这些公理
01:02:15	你可以很自然把有理数理解为序对 因为这正也是你们见到的
01:02:19	我把它说得抽象后反而影响你理解
01:02:24	那么为了让你们明白
01:02:28	我会展示一个吓到你们的东西
01:02:32	我讲带领你们零距离地面对
01:02:36	我们讨论的抽象的真实存在性
01:02:41	我们将讨论“序对”到底是什么？
01:02:45	说说 我是怎么给你们讲“序对”的？
01:02:48	我耍了你们 对吧？
01:02:49	我说 Lisp有一个叫CONS的基本过程可以构建序对
01:02:53	但我真正告诉你们什么呢？
01:02:56	如果你回过头来看 看这些幻灯片
01:02:59	会发现我真正告诉你们的是序对应该具有这些属性
01:03:04	这些CONS CAR 和 CDR构成的属性
01:03:06	而我说的“序对”
01:03:08	只是说这里面有叫CONS 叫CAR 和叫CDR的东西
01:03:14	在这个例子中 我构建了由X和Y构成的序对 取CAR部分得X
01:03:20	构建由X和Y构成的序对 取CDR部分得Y
01:03:25	尽管如此 我也对你们谎称Lisp中有个东西能这么做
01:03:32	因此你们也就假装确实有这么个东西
01:03:34	事实上 关于序对 我告诉你们的跟有理数一样多
01:03:39	都是序对的一些公理
01:03:44	言归正传 我马上要大显身手了
01:03:51	我会用某个神秘的东西来构建序对
01:03:55	你们将会看见 我们可以构建有理数
01:04:00	直线段、向量以及任何由序对构建起的东西
01:04:04	我们在低于抽象层的这里看到 序对可以凭空产生
01:04:10	纯粹的抽象
01:04:12	幻灯片中展示了CONS CAR和CDR的一种实现
01:04:21	等会儿我们会回来细看
01:04:23	但一定要注意过程CONS CAR和CDR的定义
01:04:27	这里你看不到任何数据 你只能看到一个lambda
01:04:34	这里的CONS将返回 一个返回值为新的过程的过程
01:04:41	就像函数AVERAGE-ADPT
01:04:44	(CONS A B)返回一个具有单个参数的过程pick
01:04:51	它的定义是
01:04:52	如果pick等于1 那么该过程返回a
01:04:57	而如果pick等于2 那么该过程返回b
01:05:00	这就是CONS的定义
01:05:04	取X的CAR部分 (CAR X)
01:05:10	就是把X应用于1 注意了 这完全行得通
01:05:13	你现在还不太明白我为什么要这样做 但至少这样行得通
01:05:17	因为我通过CONS构造出了一个过程
01:05:21	而CAR将其应用于1
01:05:24	类似的 CDR将其应用于2
01:05:29	好了 现在我已经给出了CONS CAR和CDR的一种表示法
01:05:32	注意这里面没有任何数据
01:05:35	这就是“凭空”产生的 它们仅仅是过程
01:05:39	这种表示法中没有任何数据对象
01:05:43	那么 这又可能意味着什么呢？
01:05:49	嗯 如果你承认这些东西的话
01:05:54	那么接下来 一旦我证明了CONS CAR CDR的这种表示法
01:05:59	能满足我们的公理的话 你就对此不容置疑了
01:06:03	那么 我来举一个例子
01:06:05	例如 (CAR (CONS 37 49))应该返回37
01:06:23	37和49是我随意挑选的任意值
01:06:26	CDR也是如此
01:06:31	如果我能用这个凭空构造的怪异过程
01:06:36	来向你们演示它能满足这些公理
01:06:41	那么你就应该认为这是CONS CAR和CDR的可行实现
01:06:47	也就可以用它们来构造其它东西了
01:06:49	好了 让我们回过头来看看 这里将用到代换模型
01:06:53	我们该怎么来说清这个过程呢？
01:07:00	我们好像知道点怎么做 这都是同一个代换模型
01:07:04	我们来瞧瞧 首先 我们考虑(CAR (CONS 37 49))是什么
01:07:10	接下来该怎么做？ CONS只是一个过程
01:07:15	它的值也就是一个有A和B的过程
01:07:19	CONS返回的是一个过程体
01:07:23	该过程体的参数被37和49代换掉了
01:07:26	用37代换A 用49代换B
01:07:32	所以这个表达式和这个表达式的意思是相同的
01:07:36	CAR没变 而CONS被代换为了一个以LAMBDA开头的表达式
01:07:42	这里PICK是另外一个变量 如果PICK为1的话
01:07:47	如果PICK等于1 那么就返回37 也就是A的值
01:07:51	如果PICK等于2 那么就返回49
01:07:54	这是代换的第一步
01:07:55	我只是进行了机械地代换
01:07:59	注意了 这也是本课的一大要点
01:08:00	当你搞不清楚情况的时候
01:08:02	就按照代换模型进行机械地代换
01:08:05	那么 这又会被归约为什么呢？
01:08:07	而CAR则是 把给定的参数 也就是这些 应用于1
01:08:15	这也就是CAR的定义
01:08:17	考虑CAR 将其展开 我将得到
01:08:22	就是将CAR的参数 将其应用于1
01:08:29	这又是什么意思呢？
01:08:30	在这里的代码体中 我拿1来替换PICK
01:08:35	也就是这个变量的名字 我们得到什么呢？
01:08:39	如果1等于1 那么就得到37
01:08:43	如果1等于2 那么就得到49 当然答案就是37
01:08:46	类似的 如果是CDR的话 也就是将其应用于2 则得到49
01:08:51	正如你们所见 我给你们演示了相当怪异的实现
01:08:56	完全符合这些公理的CONS CAR CDR实现
01:08:59	事实上 用这种方法来构建Lisp中所有的数据对象 非常有效
01:09:05	如果你愿意的话 这一切东西 都可以凭空构建
01:09:09	就目前为止 你也知道它也正是这样工作的
01:09:13	你无法分辨 你如果只是
01:09:16	将它们用CONS构建成序对 再用CAR和CDR取出来
01:09:19	你可能还无法分辨它是如何运作的
01:09:23	现在 如果我这样说 你们可能会觉得好受一点
01:09:26	我说 实际上因为种种原因 Lisp中有几个基本过程
01:09:30	叫做CONS CAR和CDR 这样不会太吓着你们
01:09:33	内部太难以理解 你就不必深究其内部了
01:09:36	这样可能会使你感觉好点
01:09:38	但关键点就是 它真是照这样运作的
01:09:41	但是这对系统而言毫无区别
01:09:46	从某种意义上来说 建立数据抽象不需要数据
01:09:51	我们可以用过程来完成所有事儿
01:09:54	恩 那么 为什么我这样做吓到你们了呢？
01:09:57	首先 我想强化大家对抽象的认识
01:10:01	也就是我们可以抽象地做事儿
01:10:05	其次 我给大家介绍了将在本课中不断体现的理念
01:10:13	也就是数据和过程的边界将变得越来越模糊
01:10:19	看到了吧 这个有趣的CONS实现结果是
01:10:24	我们以为是数据 结果却是用一个过程来表示
01:10:31	虽然这里只是一个数学技巧
01:10:34	当我们将看到的则是
01:10:36	一些非常重要的编程技巧
01:10:40	都非常依赖于
01:10:43	模糊这条传统的界定数据和过程的分界线
01:10:48	尤其在下次课 我们将接触得越来越多
01:10:52	好了 有什么问题吗？
01:10:54	学生：如果让系统打印A 会输出什么呢？
01:11:00	教授：你想问 如果我让系统打印A
01:11:04	看看这种表示法 你就知道答案了
01:11:09	这是一个复合过程A 像上次一样
01:11:21	系统返回“复合过程”
01:11:25	说着说得更详细一点 像“复合LAMBDA过程”等等
01:11:29	这得看我是如何给它命名的 但它归根是个过程
01:11:32	唯一的解释就是我并没有特别地告诉系统
01:11:37	如何打印这些东西
01:11:39	实际上 根据系统中CONS实现的不同
01:11:44	它会打印出不同的东西
01:11:47	它会打印出这是个序对
01:11:53	学生：你定义CONS后
01:11:57	你给它传递了几个值
01:12:00	它怎么知道该去哪里找这些值 毕竟你可以多次使用CONS
01:12:06	它是怎么知道我们希望取出的a和b存储在哪里呢？
01:12:12	可能表达得不是很正确 我只是想问它都存放在哪儿？
01:12:18	教授：嗯 来想想
01:12:22	我先用37和49来构造一个序对 在用1和2又构造一个
01:12:28	有一个参数为A 有一个参数为B
01:12:31	问题是 系统又是怎么知道的呢？它为什么没有弄混淆呢？
01:12:35	这个问题非常好
01:12:40	首先 你需要认定过程是一种对象
01:12:44	这就像是说——让我来换个更简单的例子
01:12:49	我想去求3的平方根
01:12:55	我这里用5的平方根来演示
01:12:57	我也可以求20的平方根
01:13:06	这可能一点也不困扰你 我可以将SQRT应用于5
01:13:10	也可以将其应用于20
01:13:14	你知道这没问题 它分得清楚应用于哪个
01:13:19	你觉得过程应该是做些事 所以没有问题
01:13:26	从某种方面来说 你问了我一个同样的问题
01:13:30	但它使你困惑
01:13:31	这确实很容易让人困惑
01:13:34	因为我当我这样写的时候 你知道这是一个过程
01:13:38	但它不是一个能运行的过程 而是一个定义在这里的过程
01:13:42	那这个过程为什么时而能有37和49
01:13:46	可能又有一个过程有5和6 但它们为什么不搞混呢
01:13:52	这里面就有一个非常重要的东西困扰了你
01:13:58	这东西非常关键
01:14:00	这就是 过程并不仅仅是动作的集合
01:14:07	过程是概念实体 是对象
01:14:11	如果我(CONS 37 49) 那么就构建好了一个特定的过程
01:14:17	这和(CONS 3 4)的那个不一样
01:14:21	这又是一个创立好的过程了
01:14:22	学生：它们都是独立存在的
01:14:23	教授：对 独立存在
01:14:25	学生：可以通过CAR和CDR被引用
01:14:28	教授：它们都可以通过CAR和CDR被引用。
01:14:30	我可以增加这个 也可以增加那个
01:14:37	它们都是对象 这也是我们需要的
01:14:41	而你之所以这样问 正是体现了
01:14:43	你开始思考它蕴含的东西了
01:14:47	过程不仅仅只是说做某件事的行为
01:14:52	任何过程都是一个存在着的真实对象
01:14:55	学生：也就是说过程在被构建时
01:14:58	A和B的确切值就被代换进去了
01:15:01	教授：是的
01:15:02	学生：那些以LAMBDA形式存在的过程
01:15:04	而PICK实际上已经被传递进去了
01:15:07	教授：是的 当CONS过程被调用时
01:15:09	CONS就返回了一个新构造好的过程
01:15:13	而这个新过程有一个叫做PICK的参数
01:15:17	学生：但是就不再有A和B了
01:15:18	A和B的确切值在那时就被传递进去了
01:15:20	教授：根据代换模型 是这样的
01:15:23	现在它不再具有这些任意的名字A和B
01:15:25	取而代之的则是37和49
01:15:31	但你是对的 把这件事想清楚很困难
01:15:33	这同我们之前对过程的认识有所不同
01:15:36	学生：如果我再次调用(CONS 37 49) 是否得到了一个不同的[听不清]
01:15:40	教授：如果你再次调用(CONS 37 49)
01:15:51	你就陷入了一个深刻的哲学问题
01:15:53	这个将是我们整个课程中段将讨论的问题
01:15:59	也就是说 我调用(CONS 37 49) 然后我再调用一次
01:16:02	这两者是同一个东西还是不同的东西呢？
01:16:06	我又该如何区别它们呢？这又在什么时候产生影响呢？
01:16:09	这就像说 这个和这个是同一个东西么？
01:16:20	那这个和这个呢？
01:16:23	这都是同一种问题
01:16:24	这将是一个非常非常深刻的问题
01:16:27	我没法在一小时内讲清楚 但我们以后会讨论
01:16:37	MIT OpenCourseWare http://ocw.mit.edu
01:16:41	本项目主页 https://github.com/FoOTOo/Learning-SICP
